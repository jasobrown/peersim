AM 17/10/2004
- RangeSimulator: now it works by calling Simulator, so we don't
  need to change two simulators. I've not invoked a new Jvm,
  because the mechanism for managing stdout and stderr are just
  awful. So, for those who are interested, using RangeSimulator
  you can write stuff like this:

  range.0 MAG;10:18

  meaning that the variable MAG will go from 10 to 18.

- Expression parsing: added
  In order to compile and run peersim, at this point, you need to 
  add to your classpath the jar file that is in attachment to
  this mail; or download it from http://www.singularsys.com/jep/

  Now you can write expression using the syntax that you can
  find here: http://www.singularsys.com/jep/doc/html/op_and_func.html
  For example,

  SIZE 2^MAG

  meaning that the value of SIZE will be included in the range
  1024:262144, if you use the RangeSimulator described above.

  You can also have complex expression trees like this:

  A B+C
  B D+E
  C E+F
  D 1
  E F
  F 2

  that results in A=7, B=3, C=4, D=1, E=2, F=2

  Expressions are parsed recursively. Note that no optimization are
  done, so expression F may be evaluated three times here (due to the
  fact that appears twice in C and once in B). But since this should 
  be done only in the initialization phase, this is not a real problem.

  Finally, recursive definitions are not allowed (and without
  function definitions, they do not mean anything). Since it is
  difficult to discover complex recursive chains, I've decided
  to use a simple trick: if the depth of recursion is greater
  than a given threshold (configurable, currently 100), an error
  message is printed. This avoid to fill the stack, that results
  in an anonymous OutOfMemoryError. So, if you write SIZE SIZE-1
  you get:

  Parameter "overlay.size": Probable recursive definition - exceeded maximum depth 100

- Protocol schedulers. 
  Now protocols are scheduled as the other objects. You can execute
  a protocol every two steps.

- Ordering, protocol names, etc.

This is the more complex change. At the end, it enables to write
config files in many different way.

The general idea is the following: let prefix be one of 
"initializer", "observer", "dynamics" or "protocol". Items are 
searched based on the the prefix, without having to be ordered 
numbers.

So, if you write 
observer.conn ConnectivityObserver
observer.0 Class1
observer.2 Class2

what you get is an array with three observers, ordered lexicographically.
Observer 0 is "0", observer 1 is "2", observer 2 is "conn".

If you have an old config file, with items numbered "0", "1", "2" 
etc, they will be ordered as usual. So it is back-compatible.

If you are not satisfied with lexicographic order, or you don't
want to execute one of the items, you can specify the order
in this way.

order.observer 2,conn,0
order.init 1
order.dynamics 2,1,0,
order.protocol sort,rank

For protocols, things are a bit more complicated. This because
you can refer to protocol in other protocols, observers, etc.
Once again, old config files works as before. This because
they are ordered in this way: "0"->0, "1"->1, "2"->2, etc,
and the Configuration.getInt(String propertyName) requests 
that we normally did return the correct protocol id.

If you want to use general names, or you want to leave holes 
between protocols (maybe commenting one of them), all the classes
that you use must obtain protocol identifiers through the new 
method int Configuration.getPid(String propertyName). This
method search in an hashtable maintained by Configuration
and built by GeneralNode when instantiating the protocols
and returns the associated protocol id.

I've already changed all the classes in the repository
(or at least, I'm pretty sure to have changed all of them...)
by substituting getInt calls with getPid ones. So, all the
classes in the repository should be ok; you need to do
the same with your classes, *if and only if* you want to
enable their use with generic names and holes for protocols
(init, observers and dynamics do not have these problems).

This version is (should be) completely compatible with the
past; so, even pre- and post-dynamic specifications should
work without problems.

But I've also added another "configuration style", that
is activated if you use the "order" parameter (just "order",
not "order.something".

At this point, you can write an order specification like
this:

order observer.0,protocol.sort,observer.2,protocol.rank,dynamics.crash

deciding the exact order in which you want to execute everything (but
initializers, that are executed at begininning, ordered by order.init).
You can also write:

order 0,sort,2,rank,crash

but all the names should be unique, otherwise it will print a message
like this:

Parameter "order": Item 0 corresponds to observer.0, dynamics.0, protocol.0

And clearly, the item name should exist, otherwise you will have
errors like this:

order pippo

Parameter "order": Item pippo does not corresponds to any of the 
observers, dynamics or protocols

You can even shuffle the network before each protocol, and not
just before each cycle, using the parameter 
simulation.shuffle.protocol.

In this style, pre- and post-dynamics of schedulers are not
considered.

AM 15/10/2004
- added the peersim.config.ClassFinder class, whose task is to
  associate non-qualified names to qualified names. 
- changed peersim.config.Configuration to use ClassFinder.
  Now it is possible to specify a non-qualified class name in
  configuration files. If a unique package-qualified class is
  found, it is used to create new instances. Otherwise,
  smart error messages are printed, when possible.


MJ 14/10/2004:
VERSION 0.1 RELEASED


AM 14/10/2004
- added maxcount and mincount to the toString method of 
  peersim.util.IncrementalStats
- added a print(String prefix) method to peersim.util.IncrementalFreq 
  that uses the Log facility to print
- protocols are not nullified in GeneralNode when the node is declared DEAD
- observers, initializers and dynamics are not required to be tagged by
  consecutive numbers any more; this is not the final version of what
  we have discussed, it is just a small hack, compatible with the past,
  that I've implemented in Configuration.java
- small changes to RangeSimulator; in any case, it will updated in order
  to be based on the Simulator code.

AM 22/6/2004:
In GeneralNode, when creating/cloning a node, the CommonState.setNode()
method is invoked to set the current node being created.

AM 22/6/2004:
peersim.cdsim.RangeSimulator, added support for idle protocols. When
a protocol has the idle flag in its specification (like protocol.0.idle),
the nextCycle method is not called. This can be useful for protocols
reuse.

AM 22/6/2004:
peersim.core.Shuffle, example.hot.InetInitializer, example.hot.RobustnessEvaluator,
example.loadbalance.AvgBalance, example.loadbalance.BasicBalance
removed unused import(s)

AM 22/6/2004:
Moved LinearDistribution, UniformDistribution and PeakDistribution to
a new package called distributions (outside peersim, but to be included
in the peersim software distribution).

Implemented NodeInitializer in LinearDistribution and UniformDistribution,
to provide values also when new nodes are added dynamically.

Added classes SingleValueHolder and SingleValueComparator

Name change: peersim.util.ExtendedStats => peersim.util.MomentStats 

Added peersim.cdsim.DaemonProtocol as a generic entry point for all
kinds of hacks, to avoid complicating the simulator. It can be used
to run observers and modifiers several times within one cycle.

Added cycle time to peersim.core.CommonState and modified
peersim.cdsim.Simulator to handle this feature. It records the number
of nodes already visited in a given cycle (makes sense only for cycle based
simulation).

Added peersim.example.hot package : classes to model a preferential
attachment internet like topology

Added peersim.util.ExtendedStats class 

peersim.util.IncrementalFreq now accepts an upper bound on the
processed values

peersim.cdsim.Simulator now outputs two blank lines between
experiments

Upgraded GraphPrinter so that it can print to files that can be
read by WireFromFile. Added method writeNeighborList to GraphIO.

Added new class peersim.dynamics.WireFromFile

Fixed bug in peersim.util.WeightedRandPerm which accepted
non-positive weights

Added peersim.reports.SingleValueObserver

Added new modifier classes, which can set numeric parameters of
network nodes according the some specified pattern. Originally this
was in aggregation but refactored to be more general.

Refactoring: added classes from peersim.init into peersim.dynamics
and now Dynamics is used also instead of the old Initializer. This
involved quite a number of files. Note that config files don't break
because the init entries are now simply loaded as dynamics that are
scheduled to execute only before the simulation, once. The change
was trivial in all files, just renaming.

Added class peersim.dynamics.Shuffle

Made class peersim.graph.NeighborListGraph public

fixed bug in GeneralNode with failstate handling

added curent node to CommonState. When a protocol is executing,
it is the node hosting the protocol. Modified simulators too to
record this info.

fixed some config files in lpbcast and scamp packages

VERSION 0.0 RELEASED


