<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>peersim HOWTO</title>
</head>
<body>
<div style="text-align: center;">
<h1 style="font-weight: bold;">PEERSIM HOWTO 2: build a topology
generator</h1>
<div style="text-align: left;">
<div style="text-align: center;"></div>
<h3 style="text-align: center;">by Gian Paolo Jesi (<a
 href="mailto:jesi@cs.unibo.it">jesi@cs.unibo.it</a>)</h3>
<span style="font-style: italic;">Last update:</span> $date 2004/05/27 17:22:08 $<br>
<h2>Introduction</h2>
This tutorial teaches you how to build from
scratch a new peersim (<a
 href="http://sourceforge.net/projects/peersim/">http://sourceforge.net/projects/peersim</a>)
topology generator.<br>
In order to understand this tutorial, the reader is encouraged to start
reading the first peersim tutorial: <a
 href="http://peersim.sourceforge.net/peersim_HOWTO.html">http://peersim.sourceforge.net/peersim_HOWTO.html</a>
to have an idea of the basic concepts that will not be discussed any
further in this document.<br>
<br>
The aim of this tutorial is to be as pratical as possible; the goal is
to give the reader ideas about technical or intermediate level features
of peersim and to encurage him/her to experiment further.<br>
The full source code discussed in this document is available via CVS at
<a href="http://sourceforge.net/projects/peersim/">peersim project page</a>
in the <span style="font-family: monospace;">peersim.example.hot</span>
class package.<br>
<h2>What is a topology?</h2>
The network abstraction in peersim is a (sometimes huge) array of Node
structures (interfaces); because of the size of the network and to
overcome
scalability problems, usually in large P2P networks each node knows
about the
existence of a very small subset of other nodes (ex: order of log(N)
where N is
the whole network size). Thus each node has a short list of other node
references, usually called "neighbors", build accordingly to some kind
of
strategy or rule.<br>
<br>
Thus, we can say that a topology is how nodes are arranged (linked)
together and
clearly this depends upon the particular choosen rule.<br>
Examples of topology are the following (not exaustive at all):<br>
<ul>
  <li>random graphs</li>
  <li>Watts-Strogatz model graph</li>
  <li>star model</li>
  <li>ring model</li>
  <li>lattice model</li>
  <li>...<br>
  </li>
</ul>
<h3>Which rule to choose?</h3>
In this document, we have choosen to code a particular topology
generator to build internet-like tree topologies. The building process
is based on the <span style="font-style: italic;">preferential
attachment</span> approach. The rule
applied is
quite simple and takes into account geometric and network constraints
to better mimic real world network. The preferential attachment choice
can be affected by a parameter (alpha) that amplifies or reduces the
geometric location influence in favor of the path distance.<br>
The rule strategy is the following: we consider a square unit region D,
then we start with node x(0) choosen at random and we set W(x(0)) = 0
(it
is
the root node). For each i with i = 1...n-1 we choose a new node x(i)
in
the region D and we connect it to an <span style="font-weight: bold;">early
inserted</span> node x(j) that
minimize the following formula:<br>
<br>
<div style="text-align: center;"><a name="Wxj__alfa__distxi_xj_with"></a>W(x(j))
+ alpha&nbsp; * dist(x(i),
x(j)) &nbsp;&nbsp; &nbsp;&nbsp; with 0 &lt;= j &lt; i<br>
</div>
<br>
where:<br>
<ul>
  <li>W(x(j)) is the distance in terms of hops (the path distance from
node x(j) to the root node);</li>
  <li>dist(...) is the usual Euclidean distance;</li>
  <li>alpha is a weight parameter that can minimize or maximize the
geometric distance influence;</li>
</ul>
After having choosen a node x(j), we set W(x(i)) = W(x(j))+1 .<br>
At the end we obtain a tree rooted in x(0).<br>
<br>
We have extended this model to improve robustness allowing every node
to have exactly d outbound neighbors instead of only one. This means
that at the time of joining the network, each node should have at least
d candidates to be selected as neighbors. To achieve this property, as
a first step we select at random exactly d root nodes and we connect
them together in a ring fashion (a doubly linked list). In this way
each ordinary node has at least d nodes (the d roots) to choose from in
order to select its neighbors; in other words, each node has to select
d nodes that minimize the <a href="#Wxj__alfa__distxi_xj_with">function</a>
above. <br>
<br>
<a name="biblio"></a>To get further details about this model, we
suggest the following
readings:<br>
<ul>
</ul>
<ol>
  <li>"Heuristically Optimized Trade-offs: A New Paradigm for Power
Laws in the Internet" (<a
 href="cgi.di.uoa.gr/%7Eelias/publications/paper-fkp02.pdf">fkp02.pdf</a>)</li>
  <li>"Degree distributions of the FKP network model" (<a
 href="research.microsoft.com/%7Ejchayes/Papers/FKPdgrees.pdf">icalp03.pdf</a>)</li>
  <li>"On Power-Law Relationships of the Internet Topology" (<a
 href="www.cs.ucr.edu/%7Emichalis/CAMERA.ps">fff.ps</a>)</li>
</ol>
The model should generate a topology that exibits a power-law bound on
the in-degree sequence of nodes; but, as atated in paper [2],&nbsp;
this power-law prediction is not true.<br>
<ul>
</ul>
<h2>What we need to code</h2>
In order to run this model in peersim we need to write java classes
extending some peersim tipical interfaces. Very in brief, we need:<br>
<ul>
  <li>the protocol class: the protocol itself does nothing because we
want something that automagically builds this topology model from a raw
list of unconnected nodes; we are not interested in running any piece
of code over time (cycles in peersim terminology). This class is a sort
of structure to collect some needed values such as the node space
coordinates, the hop distance, the in degree counter and so on. The
reader can think
to this class as "glue code".</li>
</ul>
<ul>
  <li>the initializer class: it extends the <span
 style="font-style: italic;">Initializer</span> interface and deal with
all the initialization process. As we'll see further, the initializer
code itself is very compact because all the building process complexity
is hidden in a custom made factory pattern class. Please note that we
don't need explicitly an Observer object&nbsp; because we are not
interested in
observing any behaviour over time; due to that, the code to track down
informations about the actual generated tree (coordinates and indegree
distribution) are embeeded into the initializer. <br>
  </li>
</ul>
<h2>Code writing</h2>
<h3>Protocol class</h3>
As we stated so far, the protocol code is very short:<br>
<br>
<span style="font-family: monospace;">package inet;</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">import peersim.core.IdleProtocol;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">public class InetNodeProtocol
extends IdleProtocol {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; // coordinates
in space:</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public double
x;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public double
y;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public int
in_degree;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public int
hops;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public boolean
isroot;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;</span><span
 style="font-family: monospace;">&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; /** Creates a
new instance of hotNodeProtocol */</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public
InetNodeProtocol(String prefix, Object obj) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
super(prefix);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
in_degree = 0;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
hops = 0;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
isroot = false;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public Object
clone() throws CloneNotSupportedException {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; InetNodeProtocol af = (InetNodeProtocol)
super.clone();</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return af;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public void
nextCycle(peersim.core.Node node, int protocolID) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">}<br>
<br style="font-family: monospace;">
</span>The nextCycle() method is empty, so it's presence is completely
optional. The class is basically a structure incapsulated in an object.<br>
<br>
<h3>Initializer class</h3>
This initializer can be considered as a public interface to the model.
From the outside (means from the peersim configuration file) only few
main parameters are needed, such as the <span
 style="font-style: italic;">Linkable</span>
enabled protocol, the outbound degree and the alpha parameter. The
constructor
method takes care of collecting these parameters or to set up the
corrisponding default values The actual structure generation is
performed elsewhere.<br>
<br>
<span style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">public class InetInitializer
implements peersim.init.Initializer {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; /** </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; * String
name of the parameter that defines the protocol to initialize.</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; * Parameter
read will has the full name</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; *
&lt;tt&gt;prefix+"."+PAR_PROT&lt;/tt&gt;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; */</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public static
final String PAR_PROT = "protocol";</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; /**</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; * String
name of the parameter about the out degree value.</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; */</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public static
final String PAR_OUTDEGREE = "d";</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; /**</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; * String
name of the parameter used as a weight.</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; */</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public static
final String PAR_ALFA = "alfa";</span><span
 style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; /**</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; * String
name of the parameter used as a maximum x or y coordinate. All the </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; * nodes
are on a square region.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; */</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public static
final String PAR_MAX_COORD = "max_coord";</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp; </span><span
 style="font-family: monospace;"> </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ....</span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; /** Creates a
new instance of InetInitializer */</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public
InetInitializer(String prefix) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// super(prefix);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pid = Configuration.getInt(prefix+"."+PAR_PROT);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
d = Configuration.getInt(prefix+"."+PAR_OUTDEGREE);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
alfa = Configuration.getDouble(prefix+"."+PAR_ALFA);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; graph_filename = "cmplxnet_d"+ d
+ "_alfa"+alfa+".dat";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dg_filename = "degree_d"+ d
+ "_alfa"+alfa+".dat";<br style="font-family: monospace;">
</span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
maxcoord = Configuration.getDouble(prefix + "." + PAR_MAX_COORD, 1.0);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( !graph_filename.equals("") ) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try { graph_fileout = new PrintWriter(new FileWriter(graph_filename)); </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(prefix +" filename: "+graph_filename +" selected");}</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch (Exception e) {;}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( !dg_filename.equals("") ) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try { dg_fileout = new PrintWriter(new FileWriter(dg_filename)); </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(prefix +" filename: "+dg_filename +" selected");}</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch (Exception e) {;}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <br>
</span>The initialize() method is defined by the <span
 style="font-style: italic;">Initializer</span> interface; it invokes a
specialized factory object&nbsp; that works on top of a <span
 style="font-style: italic;">OverlayGraph</span> type object (actual
implementation of the <span style="font-style: italic;">Graph</span>
interface).&nbsp; This object provides the high level abstraction of a
graph on
the simulator overlay network; in this way, it allows the application
to
use many well known graph algorithms and operations (many operations
can be found in <span style="font-style: italic;">peersim.graphGraphAlgorithms</span>
class). The operations
performed on it are reflected on the actual topology (ex: adding an
edge).<span style="font-family: monospace;"><br>
<br style="font-family: monospace;">
</span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public
void initialize() {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
OverlayGraph ogr = new OverlayGraph(pid);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
InetFactory.InetTree(ogr, CommonRandom.r, pid, maxcoord, d, alfa );</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
graphToFile(ogr);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dgDistribToFile(ogr);</span><span style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;"><br>
</span>The other two method invocation in the <span
 style="font-style: italic;">initialize()</span> method are
used to write data on disk. In the first one, for each node n the x and
y coordinates are collected and then for each neighbor i of node n the
cordinates are written in the following order: <br>
<br>
n.neighbor(i).x n.neighbor(i).y \newline<br>
n.x n.y \newline<br>
\newline<br>
<br>
The particular line triplet formatting order suits the gluplot needs.
Please note that the for loop starts from index d, not from 0; this
means that the root node(s)
is not directly considered because it has not any outbound connections,
but only inbound connections. Nevertheless the root node(s) are plotted
inspecting the nodes that are linked directly to it. <span
 style="font-family: monospace;"><br>
&nbsp;&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; private void
graphToFile(peersim.graph.Graph g) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (graph_fileout != null) { </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = d ; i &lt; g.size() ; i++ ) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node current = (Node)g.getNode(i);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double x_to = ((InetNodeProtocol)current.getProtocol(pid)).x;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double y_to = ((InetNodeProtocol)current.getProtocol(pid)).y;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Iterator it = (Iterator)g.getNeighbours(i).iterator();</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
while (it.hasNext()) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int index = ((Integer)it.next()).intValue();</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node n = (Node)g.getNode(index);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double x_from = ((InetNodeProtocol)n.getProtocol(pid)).x;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double y_from = ((InetNodeProtocol)n.getProtocol(pid)).y;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
graph_fileout.println(x_from+" "+y_from);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
graph_fileout.println(x_to+" "+y_to);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
graph_fileout.println("");</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
graph_fileout.close();</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch (Exception e) {;}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <br>
</span>The second data collecting method builds an array of indegree
frequencies and an array of indegree probability and dumps the second
collection to file.<span style="font-family: monospace;"><br>
<br style="font-family: monospace;">
</span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; private
void dgDistribToFile(peersim.graph.Graph g) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (dg_fileout != null) { </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int size = g.size();</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int[] dgfrq = new int[size];</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double[] dgprob = new double[size];</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = 0 ; i &lt; size ; i++) { // do not plot leaves</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node n = (Node)g.getNode(i);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
InetNodeProtocol protocol = (InetNodeProtocol)n.getProtocol(pid);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int degree = protocol.in_degree;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dgfrq[degree]++;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double sum = 0;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = size-1 ; i &gt; 0 ; i--) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dgprob[i] = (dgfrq[i] + sum)/size;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sum += dgfrq[i];</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// do not count index 0: 'cos the leafs degree is clearly 0!</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = 0 ; i &lt; dgprob.length ; i++ ) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double k = (double)i/size;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style="font-family: monospace;">dg_fileout.println(k+"
"+dgprob[i]);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dg_fileout.close();</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch (Exception e) {e.printStackTrace();</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(e);}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">}</span><br>
&nbsp;&nbsp;&nbsp; <br>
<h3>Factory class</h3>
This class is the core one. The actual topology initialization is
performed here. Because of the factory pattern, al the methods in this
class are static. There is no need of getting parameters from the
configuration file, because they have been already collected by the
initializer class; thus the factory is completely hidden.<br>
This implementation is an extention of the peersim standard topology
factory (<span style="font-style: italic;">peersim.graph.GraphFactory</span>).<br>
The only public method is the one that actually builds the topology:
<span style="font-style: italic;">InetTree()</span>; as parameters it
gets all the parameters that the
initializer class has collected. The steps performed are the following:<br>
<br>
<ol>
  <li>set the correct values for the d (at least one!) roots, including
coordinates; if there is only one root, its coordinates are centered on
the square (edge size 1.0 by default), otherwise the coordinates are
random (as any ordinary node).<br>
  </li>
  <li>initialize the coordinates and the indegree counter for each
ordinary node.</li>
  <li>if there are more than one root node, than these root nodes are
joined together in a ring (connections are non oriented). As an
exercise, the reader
can
change this choice implementing something else (ex: putting the root
nodes in a fully connected topology or a random graph or whatever).</li>
  <li>for each node n other than the root, take exactly d nodes that
minimizes the <a href="#Wxj__alfa__distxi_xj_with">formula</a> and
connect node n to those d nodes.<br>
  </li>
</ol>
The other present methods are all private and can be considered as
utility methods. Infact their function is quite straightforward and can
be guessed by the method signature; nevertheless a few comments are
presented in the following table:<br>
<br>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; width: 100%;">
  <tbody>
    <tr>
      <td style="vertical-align: top;">getParents()<br>
      </td>
      <td style="vertical-align: top;">get the the
current node best d candidates to connect to</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">hops()<br>
      </td>
      <td style="vertical-align: top;">return the graph distance in
terms of hops from the root of the node given as a parameter<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">minHops()<br>
      </td>
      <td style="vertical-align: top;">return the minimum hop valued
node between the specified nodes<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">distance()<br>
      </td>
      <td style="vertical-align: top;">get the standard Euclideian
distance between two nodes<br>
      </td>
    </tr>
  </tbody>
</table>
<span style="font-family: monospace;"><br>
</span><br>
<span style="font-family: monospace;">package inet;</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">import hot.HotNodeProtocol;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">import peersim.graph.*;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">import peersim.core.Node;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">import peersim.core.Linkable;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">import peersim.core.Network;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">import
peersim.config.Configuration;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">import java.util.Random;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">import java.util.ArrayList;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">import java.util.Arrays;</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">public class InetFactory extends
peersim.graph.GraphFactory {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; private static
final String DEBUG_STRING = "inet.InetFactory: ";</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp; </span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public
InetFactory() {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
super();</span><span style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; public static
Graph InetTree(Graph g, Random rnd, int pid, double maxcoord, int
outdegree, double alfa) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int size = g.size(); // size of the network</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(DEBUG_STRING+"size: "+size+" outdegree: "+outdegree);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// build outdegree roots</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(DEBUG_STRING+"Generating "+outdegree+" root(s),
means out degree "+outdegree+"...");</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for(int i = 0 ; i &lt; outdegree ; ++i) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node n = (Node)g.getNode(i);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HotNodeProtocol prot = (HotNodeProtocol)n.getProtocol(pid);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.isroot = true;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.hops = 0;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.in_degree = 0;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (outdegree
== 1 ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.x = maxcoord/2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.y = maxcoord/2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
{ // more than one root<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (rnd.nextBoolean() ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.x = maxcoord/2 + (rnd.nextDouble() * 0.1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.x = maxcoord/2 - (rnd.nextDouble() * 0.1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (rnd.nextBoolean() ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.y = maxcoord/2 + (rnd.nextDouble() * 0.1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.y = maxcoord/2 - (rnd.nextDouble() * 0.1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println("root coord: "+prot.x+" "+prot.y);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><span
 style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Set coordinates x,y and set indegree 0</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(DEBUG_STRING+"Generating random cordinates for
nodes...");</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = outdegree ; i &lt; size ; i++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node n = (Node)g.getNode(i);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HotNodeProtocol prot = (HotNodeProtocol)n.getProtocol(pid);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; if (maxcoord ==
1.0) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.x = rnd.nextDouble();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.y = rnd.nextDouble();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.x = rnd.nextInt((int)maxcoord);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.y = rnd.nextInt((int)maxcoord);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.in_degree = 0;<br>
</span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Connect the roots in a ring if needed (thus, if there are more than 1</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// root nodes.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (outdegree &gt; 1) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(DEBUG_STRING+"Putting roots in a ring...");</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = 0 ; i &lt; outdegree ; i++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node n = (Node)g.getNode(i);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((HotNodeProtocol)n.getProtocol(pid)).in_degree++;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
n = (Node)g.getNode(i+1);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((HotNodeProtocol)n.getProtocol(pid)).in_degree++;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g.setEdge(i, i+1);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g.setEdge(i+1, i);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node n = (Node)g.getNode(0);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((HotNodeProtocol)n.getProtocol(pid)).in_degree++;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
n = (Node)g.getNode(outdegree);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((HotNodeProtocol)n.getProtocol(pid)).in_degree++;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g.setEdge(0, outdegree);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g.setEdge(outdegree, 0);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// for all the nodes other than root(s), connect them!</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = outdegree ; i &lt; size ; ++i ) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style="font-family: monospace;">Node n =
(Node)g.getNode(i);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
InetNodeProtocol prot = (InetNodeProtocol)n.getProtocol(pid);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.isroot = false;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// look for a siutable parent node between those allready part of the</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// overlay topology: alias FIND THE MINIMUM!</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node candidate = null;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int candidate_index = 0;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double min = Double.POSITIVE_INFINITY;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (outdegree &gt; 1) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int candidates[] = getParents(g, pid, i, outdegree, alfa);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
 style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int s = 0 ; s &lt; candidates.length ; s++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g.setEdge(i, candidates[s]);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.print(i+", ");</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.hops = minHop(g, candidates, pid) + 1;</span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else { // degree 1:</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int j = 0 ; j &lt; i ; j++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node parent = (Node)g.getNode(j);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
InetNodeProtocol prot_parent =
(InetNodeProtocol)parent.getProtocol(pid);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double value = hops(parent, pid) + </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(alfa * distance(n, parent, pid));</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (value &lt; min) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
candidate = parent; // best parent node to connect to</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
min = value;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
candidate_index = j;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
prot.hops = ((InetNodeProtocol)candidate.getProtocol(pid)).hops + 1; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g.setEdge(i, candidate_index);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((HotNodeProtocol)candidate.getProtocol(pid)).in_degree++;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style="font-family: monospace;">}</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.out.println(DEBUG_STRING+"Graph generation finished!");</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return g;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><span
 style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; private static
int[] getParents(Graph g, int pid, int cur_node_index, int how_many,
double alfa) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int result[] = new int[how_many];</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ArrayList net_copy = new ArrayList(cur_node_index);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// fill up the sub net copy:</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int j = 0 ; j &lt; cur_node_index ; j++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
net_copy.add(j, (Node)g.getNode(j));</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// it needs exactly how_many minimums!</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int k = 0 ; k &lt; how_many ; k++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int candidate_index = 0;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double min = Double.POSITIVE_INFINITY;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// for all the elements in the copy...</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int j = 0 ; j &lt; net_copy.size() ; j++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node parent = (Node)net_copy.get(j);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HotNodeProtocol prot_parent = (HotNodeProtocol)parent.getProtocol(pid);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style="font-family: monospace;">double value =
hops(parent, pid) + (alfa * </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
distance((Node)g.getNode(cur_node_index), parent, pid));</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (value &lt; min) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
min = value;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
candidate_index = j;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
result[k] = candidate_index;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// collect the parent node</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
net_copy.remove(candidate_index); // delete the min from the net copy </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return result;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><br
 style="font-family: monospace;">
<span style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; private static
int hops(Node node, int pid) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return ((HotNodeProtocol)node.getProtocol(pid)).hops;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; </span><span
 style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; private static
int minHop(Graph g, int[] indexes, int pid) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int min = Integer.MAX_VALUE; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int s = 0 ; s &lt; indexes.length ; s++) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node parent = (Node)g.getNode(indexes[s]);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int value = ((HotNodeProtocol)parent.getProtocol(pid)).hops;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (value &lt; min) {</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
min = value;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return min;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; </span><span
 style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; private static
double distance(Node new_node, Node old_node, int pid) {</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double x1 = ((HotNodeProtocol)new_node.getProtocol(pid)).x;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double x2 = ((HotNodeProtocol)old_node.getProtocol(pid)).x;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double y1 = ((HotNodeProtocol)new_node.getProtocol(pid)).y;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double y2 = ((HotNodeProtocol)old_node.getProtocol(pid)).y;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return Math.sqrt( Math.pow((x1-x2),2) + Math.pow((y1-y2),2) );</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }&nbsp;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">}</span><br>
<br>
<h2>Experiments</h2>
In order to make the model run, a proper peersim configuration file is
needed. The one presented in the following lines may suits the reader
needs:<br>
<br>
<span style="font-family: monospace;"># Complex Network file:</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">random.seed 1234567890</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">simulation.cycles 1</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">overlay.size 10000</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">overlay.maxSize 10000</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">protocol.0 hot.InetNodeProtocol</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">#protocol.0.maxcoord 1000</span><br
 style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">init.0 hot.InetInitializer</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">init.0.alfa 20</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">init.0.protocol 0</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">init.0.d 1</span><span
 style="font-family: monospace;"></span><span
 style="font-family: monospace;"></span><br>
<br>
It produces a 10000 node overlay network with the parameters listed in
the <span style="font-family: monospace;">init.0</span> section.<br>
The figures in the <a href="#Table1:">table</a> shows the produced
topology and highlights the parameter alpha importance. Infact it
affects
the clustering behaviour of the system and it is tightly correlated to
the size of the network. If alpha il lower than sqrt(netsize), the
topology becomes more and more clusterized (as show in the first two
figures); with extremely low alpha, the topology becomes a star. On the
other end, if alpha is grater than sqrt(netsize), the topology tends to
be random and not clusterized at all (the second row of images). For
deeper details, please consult the <a href="#biblio">paper list</a>
above.<br>
<br>
All the images has been produced using only one root node and only one
outbound connection per node. Using two or more outbound connection per
node leads to a massively crowded plot, so it's not a very nice picture
to plot!<br>
<br>
<div style="text-align: center;"><a name="Table1:"></a>Table1:<br>
</div>
<table style="text-align: left; width: 897px; height: 546px;" border="0"
 cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1"
 style="vertical-align: top; text-align: center;"><img
 style="width: 350px; height: 263px;" alt="Topology with ALFA 0.1"
 title="Topology with ALFA 0.1" src="pic/pic_alfa01.jpeg"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-align: center;"><img
 style="width: 450px; height: 338px;" alt="Topology with ALFA 4"
 title="Topology with ALFA 4" src="pic/pic_alfa4.jpeg"><br>
      </td>
      <td style="vertical-align: top; text-align: center;"><img
 style="width: 450px; height: 338px;"
 alt="INDegree distribution with ALFA 4"
 title="INDegree distribution with ALFA 4"
 src="pic/picdegree_alfa4.jpeg"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-align: center;"><img
 src="pic/pic_alfa20.jpeg" title="Topology with ALFA 20"
 alt="Topology with ALFA 20" style="width: 450px; height: 338px;"
 align="middle"></td>
      <td style="vertical-align: top; text-align: center;"><img
 style="width: 450px; height: 338px;"
 alt="INDegree distribution with ALFA 20"
 title="INDegree distribution with ALFA 20"
 src="pic/picdegree_alfa20.jpeg"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-align: center;"><img
 style="width: 450px; height: 338px;" alt="Topology with ALFA 100"
 title="Topology with ALFA 100" src="pic/pic_alfa100.jpeg"><br>
      </td>
      <td style="vertical-align: top; text-align: center;"><img
 style="width: 450px; height: 338px;"
 alt="INDegree distribution with ALFA 100"
 title="INDegree distribution with ALFA 100"
 src="pic/picdegree_alfa100.jpeg"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-align: center;"><img
 src="pic/pic_alfa2000.jpeg" title="Topology with ALFA 2000"
 alt="Topology with ALFA 2000" style="width: 450px; height: 338px;"></td>
      <td style="vertical-align: top; text-align: center;"><img
 style="width: 450px; height: 338px;"
 alt="INDegree distribution with ALFA 2000"
 title="INDegree distribution with ALFA 2000"
 src="pic/picdegree_alfa2000.jpeg"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</div>
</div>
The degree distribution related to the generated star topology is not
shown (it's simply a straight line!).<br>
Clearly the plots show that there is not any evidence about in-degree
power-law distribution; only in the case of alpha = 4, the
corrisponding plot exibits a power-law like behaviour at least for a
subset of the nodes, but this is very different from what paper [1] was
talking about.<br>
<br>
<hr style="width: 100%; height: 2px;"><br>
<span style="font-style: italic;">Last update:</span> $date 2004/05/27 17:22:08 $<br>
<span style="font-style: italic;"></span><br>
</body>
</html>
